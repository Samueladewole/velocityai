/**
 * ATLAS Comprehensive Vulnerability Scanner
 * Multi-source vulnerability intelligence with EU-specific integration
 */

export interface VulnerabilitySource {
  id: string
  name: string
  type: 'global' | 'european' | 'commercial' | 'opensource'
  apiEndpoint: string
  updateFrequency: string
  reliability: number
}

export interface CVEData {
  id: string
  description: string
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW'
  cvssScore: number
  cvssVector: string
  epssScore?: number
  publishedDate: Date
  lastModified: Date
  references: string[]
  cwe?: string[]
  attackVector?: string
  attackComplexity?: string
  privilegesRequired?: string
  userInteraction?: string
  scope?: string
  confidentialityImpact?: string
  integrityImpact?: string
  availabilityImpact?: string
}

export interface MITREAttackMapping {
  techniqueId: string
  techniqueName: string
  tactic: string
  subTechnique?: string
  procedure: string
  platforms: string[]
  dataSource: string[]
  mitigation: string[]
  detection: string[]
}

export interface EUThreatData {
  id: string
  source: 'ENISA' | 'CERT-EU' | 'BSI' | 'ANSSI' | 'NCSC-NL'
  title: string
  description: string
  severity: string
  affectedSectors: string[]
  recommendedActions: string[]
  nis2Relevance: boolean
  doraImpact: boolean
  gdprRisk: boolean
  publishedDate: Date
  language: string
}

export interface VulnerabilityCorrelation {
  cveId: string
  enisaRef?: string
  certEuRef?: string
  nationalCertRefs: string[]
  mitreAttackTechniques: MITREAttackMapping[]
  exploitAvailable: boolean
  exploitMaturity: 'FUNCTIONAL' | 'POC' | 'HIGH' | 'UNPROVEN'
  cisaKevListed: boolean
  threatIntelligence: {
    activeExploitation: boolean
    threatActors: string[]
    campaigns: string[]
    geographicTargeting: string[]
  }
}

export interface RegulatoryMapping {
  nis2Impact: {
    articleRelevance: string[]
    incidentReporting: boolean
    riskAssessment: boolean
    securityMeasures: string[]
  }
  doraRequirements: {
    ictRiskFramework: boolean
    thirdPartyRisk: boolean
    incidentReporting: boolean
    testingRequirements: string[]
  }
  gdprImplications: {
    dataBreachRisk: 'HIGH' | 'MEDIUM' | 'LOW'
    notificationRequired: boolean
    affectedDataTypes: string[]
    impactAssessment: string
  }
  craCompliance: {
    essentialRequirements: string[]
    conformityAssessment: boolean
    postMarketSurveillance: boolean
  }
}

export interface ScanResult {
  assetId: string
  vulnerabilities: VulnerabilityCorrelation[]
  attackPaths: AttackPath[]
  riskScore: number
  priorityLevel: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW'
  regulatoryImpact: RegulatoryMapping
  recommendedActions: string[]
  scanMetadata: {
    timestamp: Date
    scanDuration: number
    sourcesUsed: string[]
    confidence: number
  }
}

export interface AttackPath {
  id: string
  name: string
  description: string
  steps: AttackStep[]
  likelihood: number
  impact: number
  mitigations: string[]
  detectionMethods: string[]
}

export interface AttackStep {
  sequence: number
  technique: string
  description: string
  prerequisites: string[]
  tools: string[]
  indicators: string[]
}

export class ComprehensiveVulnerabilityScanner {
  private sources: Map<string, VulnerabilitySource> = new Map()
  private correlationCache: Map<string, VulnerabilityCorrelation> = new Map()
  private lastUpdate: Map<string, Date> = new Map()

  constructor() {
    this.initializeSources()
  }

  private initializeSources(): void {
    // Global Sources
    this.sources.set('nvd', {
      id: 'nvd',
      name: 'National Vulnerability Database',
      type: 'global',
      apiEndpoint: 'https://services.nvd.nist.gov/rest/json/cves/2.0',
      updateFrequency: 'real-time',
      reliability: 0.95
    })

    this.sources.set('mitre-attack', {
      id: 'mitre-attack',
      name: 'MITRE ATT&CK',
      type: 'global',
      apiEndpoint: 'https://attack.mitre.org/api/v1',
      updateFrequency: 'quarterly',
      reliability: 0.98
    })

    this.sources.set('cisa-kev', {
      id: 'cisa-kev',
      name: 'CISA Known Exploited Vulnerabilities',
      type: 'global',
      apiEndpoint: 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json',
      updateFrequency: 'weekly',
      reliability: 0.99
    })

    // EU Sources
    this.sources.set('enisa', {
      id: 'enisa',
      name: 'ENISA Threat Landscape',
      type: 'european',
      apiEndpoint: 'https://www.enisa.europa.eu/api/threats',
      updateFrequency: 'monthly',
      reliability: 0.90
    })

    this.sources.set('cert-eu', {
      id: 'cert-eu',
      name: 'CERT-EU Advisories',
      type: 'european',
      apiEndpoint: 'https://cert.europa.eu/api/advisories',
      updateFrequency: 'daily',
      reliability: 0.92
    })

    this.sources.set('bsi', {
      id: 'bsi',
      name: 'BSI Germany',
      type: 'european',
      apiEndpoint: 'https://www.bsi.bund.de/api/vulnerabilities',
      updateFrequency: 'daily',
      reliability: 0.88
    })
  }

  /**
   * Comprehensive vulnerability scan with multi-source correlation
   */
  async scanAssets(assets: string[]): Promise<ScanResult[]> {
    const scanStart = Date.now()
    const results: ScanResult[] = []

    console.log(`üîç Starting comprehensive vulnerability scan for ‚Ç¨{assets.length} assets`)

    for (const assetId of assets) {
      try {
        // Collect vulnerability data from all sources
        const vulnerabilityData = await this.collectVulnerabilityData(assetId)
        
        // Correlate findings across sources
        const correlatedVulns = await this.correlateVulnerabilities(vulnerabilityData)
        
        // Generate attack paths using MITRE ATT&CK
        const attackPaths = await this.generateAttackPaths(correlatedVulns)
        
        // Assess regulatory impact
        const regulatoryImpact = await this.assessRegulatoryImpact(correlatedVulns)
        
        // Calculate risk score
        const riskScore = this.calculateRiskScore(correlatedVulns, attackPaths)
        
        // Generate recommendations
        const recommendations = this.generateRecommendations(correlatedVulns, regulatoryImpact)

        const scanResult: ScanResult = {
          assetId,
          vulnerabilities: correlatedVulns,
          attackPaths,
          riskScore,
          priorityLevel: this.determinePriority(riskScore),
          regulatoryImpact,
          recommendedActions: recommendations,
          scanMetadata: {
            timestamp: new Date(),
            scanDuration: Date.now() - scanStart,
            sourcesUsed: Array.from(this.sources.keys()),
            confidence: this.calculateConfidence(correlatedVulns)
          }
        }

        results.push(scanResult)
        console.log(`‚úÖ Completed scan for asset ‚Ç¨{assetId}: ‚Ç¨{correlatedVulns.length} vulnerabilities found`)

      } catch (error) {
        console.error(`‚ùå Scan failed for asset ‚Ç¨{assetId}:`, error)
      }
    }

    console.log(`üéØ Vulnerability scan completed in ‚Ç¨{Date.now() - scanStart}ms`)
    return results
  }

  /**
   * Collect vulnerability data from all configured sources
   */
  private async collectVulnerabilityData(assetId: string): Promise<any[]> {
    const promises = []

    // Global sources
    promises.push(this.fetchNVDData(assetId))
    promises.push(this.fetchMITREData(assetId))
    promises.push(this.fetchCISAKEV(assetId))

    // EU sources
    promises.push(this.fetchENISAData(assetId))
    promises.push(this.fetchCERTEUData(assetId))
    promises.push(this.fetchBSIData(assetId))

    // Commercial/Open source
    promises.push(this.fetchExploitDBData(assetId))
    promises.push(this.fetchVulnersData(assetId))

    const results = await Promise.allSettled(promises)
    return results
      .filter(result => result.status === 'fulfilled')
      .map(result => (result as PromiseFulfilledResult<any>).value)
      .flat()
  }

  /**
   * Correlate vulnerabilities across multiple sources
   */
  private async correlateVulnerabilities(data: any[]): Promise<VulnerabilityCorrelation[]> {
    const correlations: Map<string, VulnerabilityCorrelation> = new Map()

    for (const item of data) {
      if (item.cveId) {
        let correlation = correlations.get(item.cveId)
        
        if (!correlation) {
          correlation = {
            cveId: item.cveId,
            mitreAttackTechniques: [],
            exploitAvailable: false,
            exploitMaturity: 'UNPROVEN',
            cisaKevListed: false,
            nationalCertRefs: [],
            threatIntelligence: {
              activeExploitation: false,
              threatActors: [],
              campaigns: [],
              geographicTargeting: []
            }
          }
          correlations.set(item.cveId, correlation)
        }

        // Enrich correlation with source-specific data
        this.enrichCorrelation(correlation, item)
      }
    }

    return Array.from(correlations.values())
  }

  /**
   * Generate attack paths using MITRE ATT&CK framework
   */
  private async generateAttackPaths(vulnerabilities: VulnerabilityCorrelation[]): Promise<AttackPath[]> {
    const attackPaths: AttackPath[] = []

    for (const vuln of vulnerabilities) {
      for (const technique of vuln.mitreAttackTechniques) {
        const path: AttackPath = {
          id: `‚Ç¨{vuln.cveId}-‚Ç¨{technique.techniqueId}`,
          name: `‚Ç¨{technique.techniqueName} via ‚Ç¨{vuln.cveId}`,
          description: `Attack path leveraging ‚Ç¨{vuln.cveId} to execute ‚Ç¨{technique.techniqueName}`,
          steps: this.generateAttackSteps(technique),
          likelihood: this.calculateAttackLikelihood(vuln, technique),
          impact: this.calculateAttackImpact(technique),
          mitigations: technique.mitigation,
          detectionMethods: technique.detection
        }
        attackPaths.push(path)
      }
    }

    return attackPaths
  }

  /**
   * Assess regulatory impact for EU compliance
   */
  private async assessRegulatoryImpact(vulnerabilities: VulnerabilityCorrelation[]): Promise<RegulatoryMapping> {
    const impact: RegulatoryMapping = {
      nis2Impact: {
        articleRelevance: [],
        incidentReporting: false,
        riskAssessment: false,
        securityMeasures: []
      },
      doraRequirements: {
        ictRiskFramework: false,
        thirdPartyRisk: false,
        incidentReporting: false,
        testingRequirements: []
      },
      gdprImplications: {
        dataBreachRisk: 'LOW',
        notificationRequired: false,
        affectedDataTypes: [],
        impactAssessment: ''
      },
      craCompliance: {
        essentialRequirements: [],
        conformityAssessment: false,
        postMarketSurveillance: false
      }
    }

    // Analyze vulnerabilities for regulatory implications
    for (const vuln of vulnerabilities) {
      this.mapToNIS2(vuln, impact)
      this.mapToDORA(vuln, impact)
      this.assessGDPRRisk(vuln, impact)
      this.mapToCRA(vuln, impact)
    }

    return impact
  }

  /**
   * Source-specific data fetching methods
   */
  private async fetchNVDData(assetId: string): Promise<CVEData[]> {
    // Simulate NVD API call
    return [
      {
        id: 'CVE-2024-0001',
        description: 'Critical remote code execution vulnerability',
        severity: 'CRITICAL',
        cvssScore: 9.8,
        cvssVector: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
        epssScore: 0.95,
        publishedDate: new Date('2024-01-15'),
        lastModified: new Date('2024-01-20'),
        references: ['https://nvd.nist.gov/vuln/detail/CVE-2024-0001'],
        cwe: ['CWE-787'],
        attackVector: 'NETWORK',
        attackComplexity: 'LOW',
        privilegesRequired: 'NONE',
        userInteraction: 'NONE',
        scope: 'UNCHANGED',
        confidentialityImpact: 'HIGH',
        integrityImpact: 'HIGH',
        availabilityImpact: 'HIGH'
      }
    ]
  }

  private async fetchMITREData(assetId: string): Promise<MITREAttackMapping[]> {
    return [
      {
        techniqueId: 'T1190',
        techniqueName: 'Exploit Public-Facing Application',
        tactic: 'Initial Access',
        procedure: 'Exploitation of web application vulnerabilities',
        platforms: ['Linux', 'Windows', 'macOS'],
        dataSource: ['Web logs', 'Network monitoring'],
        mitigation: ['Application Isolation', 'Privileged Account Management'],
        detection: ['Network intrusion detection', 'Web application firewall']
      }
    ]
  }

  private async fetchCISAKEV(assetId: string): Promise<any[]> {
    return [
      {
        cveId: 'CVE-2024-0001',
        dateAdded: '2024-01-16',
        dueDate: '2024-02-16',
        requiredAction: 'Apply security updates'
      }
    ]
  }

  private async fetchENISAData(assetId: string): Promise<EUThreatData[]> {
    return [
      {
        id: 'ENISA-2024-001',
        source: 'ENISA',
        title: 'Critical Infrastructure Vulnerability Alert',
        description: 'High-impact vulnerability affecting critical infrastructure',
        severity: 'HIGH',
        affectedSectors: ['Energy', 'Finance', 'Healthcare'],
        recommendedActions: ['Immediate patching', 'Enhanced monitoring'],
        nis2Relevance: true,
        doraImpact: true,
        gdprRisk: true,
        publishedDate: new Date('2024-01-16'),
        language: 'en'
      }
    ]
  }

  private async fetchCERTEUData(assetId: string): Promise<any[]> {
    return []
  }

  private async fetchBSIData(assetId: string): Promise<any[]> {
    return []
  }

  private async fetchExploitDBData(assetId: string): Promise<any[]> {
    return []
  }

  private async fetchVulnersData(assetId: string): Promise<any[]> {
    return []
  }

  /**
   * Helper methods for correlation and analysis
   */
  private enrichCorrelation(correlation: VulnerabilityCorrelation, data: any): void {
    if (data.source === 'CISA-KEV') {
      correlation.cisaKevListed = true
    }
    
    if (data.exploitAvailable) {
      correlation.exploitAvailable = true
      correlation.exploitMaturity = data.exploitMaturity || 'POC'
    }

    if (data.mitreMapping) {
      correlation.mitreAttackTechniques.push(...data.mitreMapping)
    }
  }

  private generateAttackSteps(technique: MITREAttackMapping): AttackStep[] {
    return [
      {
        sequence: 1,
        technique: technique.techniqueId,
        description: `Execute ‚Ç¨{technique.techniqueName}`,
        prerequisites: ['Network access', 'Vulnerable service'],
        tools: ['Custom exploit', 'Metasploit'],
        indicators: ['Unusual network traffic', 'Process execution']
      }
    ]
  }

  private calculateAttackLikelihood(vuln: VulnerabilityCorrelation, technique: MITREAttackMapping): number {
    let likelihood = 0.3 // Base likelihood

    if (vuln.exploitAvailable) likelihood += 0.3
    if (vuln.cisaKevListed) likelihood += 0.2
    if (vuln.threatIntelligence.activeExploitation) likelihood += 0.4

    return Math.min(likelihood, 1.0)
  }

  private calculateAttackImpact(technique: MITREAttackMapping): number {
    // Impact based on tactic and technique
    const impactMap: Record<string, number> = {
      'Initial Access': 0.7,
      'Execution': 0.8,
      'Persistence': 0.6,
      'Privilege Escalation': 0.9,
      'Defense Evasion': 0.5,
      'Credential Access': 0.8,
      'Discovery': 0.4,
      'Lateral Movement': 0.7,
      'Collection': 0.6,
      'Command and Control': 0.7,
      'Exfiltration': 0.9,
      'Impact': 1.0
    }

    return impactMap[technique.tactic] || 0.5
  }

  private mapToNIS2(vuln: VulnerabilityCorrelation, impact: RegulatoryMapping): void {
    // Map vulnerability to NIS2 requirements
    if (vuln.threatIntelligence.activeExploitation) {
      impact.nis2Impact.incidentReporting = true
      impact.nis2Impact.articleRelevance.push('Article 23 - Incident reporting')
    }
  }

  private mapToDORA(vuln: VulnerabilityCorrelation, impact: RegulatoryMapping): void {
    // Map vulnerability to DORA requirements
    if (vuln.exploitAvailable) {
      impact.doraRequirements.ictRiskFramework = true
      impact.doraRequirements.testingRequirements.push('Vulnerability testing')
    }
  }

  private assessGDPRRisk(vuln: VulnerabilityCorrelation, impact: RegulatoryMapping): void {
    // Assess GDPR data breach risk
    const dataExposureRisk = vuln.mitreAttackTechniques.some(t => 
      t.tactic === 'Collection' || t.tactic === 'Exfiltration'
    )

    if (dataExposureRisk) {
      impact.gdprImplications.dataBreachRisk = 'HIGH'
      impact.gdprImplications.notificationRequired = true
      impact.gdprImplications.affectedDataTypes.push('Personal data')
    }
  }

  private mapToCRA(vuln: VulnerabilityCorrelation, impact: RegulatoryMapping): void {
    // Map vulnerability to Cyber Resilience Act
    if (vuln.exploitAvailable) {
      impact.craCompliance.essentialRequirements.push('Cybersecurity by design')
      impact.craCompliance.postMarketSurveillance = true
    }
  }

  private calculateRiskScore(vulns: VulnerabilityCorrelation[], paths: AttackPath[]): number {
    let score = 0

    for (const vuln of vulns) {
      // Base score from threat intelligence
      score += vuln.threatIntelligence.activeExploitation ? 30 : 10
      score += vuln.cisaKevListed ? 20 : 0
      score += vuln.exploitAvailable ? 15 : 0
    }

    for (const path of paths) {
      score += path.likelihood * path.impact * 25
    }

    return Math.min(score, 100)
  }

  private determinePriority(riskScore: number): 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' {
    if (riskScore >= 80) return 'CRITICAL'
    if (riskScore >= 60) return 'HIGH'
    if (riskScore >= 40) return 'MEDIUM'
    return 'LOW'
  }

  private calculateConfidence(vulns: VulnerabilityCorrelation[]): number {
    if (vulns.length === 0) return 0
    
    const sourceReliability = 0.9 // Average reliability of sources
    const dataFreshness = 0.95 // How recent the data is
    const correlationStrength = 0.85 // How well sources agree
    
    return sourceReliability * dataFreshness * correlationStrength
  }

  private generateRecommendations(vulns: VulnerabilityCorrelation[], regulatory: RegulatoryMapping): string[] {
    const recommendations: string[] = []

    // Critical vulnerabilities
    const criticalVulns = vulns.filter(v => v.cisaKevListed || v.threatIntelligence.activeExploitation)
    if (criticalVulns.length > 0) {
      recommendations.push('üö® URGENT: Apply security patches for actively exploited vulnerabilities')
    }

    // EU regulatory compliance
    if (regulatory.nis2Impact.incidentReporting) {
      recommendations.push('üìã NIS2: Prepare incident report within 24 hours')
    }

    if (regulatory.gdprImplications.notificationRequired) {
      recommendations.push('‚öñÔ∏è GDPR: Assess data breach notification requirements (72 hours)')
    }

    // General security measures
    recommendations.push('üîç Implement continuous monitoring for attack techniques')
    recommendations.push('üõ°Ô∏è Deploy compensating controls where patching is delayed')
    recommendations.push('üìä Review and update incident response procedures')

    return recommendations
  }
}

export default ComprehensiveVulnerabilityScanner